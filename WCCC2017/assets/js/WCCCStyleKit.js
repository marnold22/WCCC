'use strict';

//
//  WCCCStyleKit.js
//  WCCC
//
//  Created by Tyler Reardon on 4/8/17.
//  Copyright Â© 2017 Pacific North Dev. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//


//// APIs you can use in your code:
//
// Available methods for drawing into <canvas> elements:
//    WCCCStyleKit.drawBurgerMenu(canvas, progress, targetFrame*, resizing*)
//
// Available methods that return generated images:
//    WCCCStyleKit.imageOfBurgerMenu(pixelRatio, progress)
//
// NOTE: 'canvas' parameter can be either a <canvas> element object, or the id of a <canvas> element in your document.
//
// NOTE: Parameters marked with the '*' symbol are optional
//
// NOTE: Possible arguments for 'resizing' parameter in drawing methods are:
//   'aspectfit': The content is proportionally resized to fit into the target rectangle.
//   'aspectfill': The content is proportionally resized to completely fill the target rectangle.
//   'stretch': The content is stretched to match the entire target rectangle.
//   'center': The content is centered in the target rectangle, but it is NOT resized.
//
// Available Utilities:
//    WCCCStyleKit.clearCanvas(canvas)
//    WCCCStyleKit.makeRect(x, y, width, height)


//// Create StyleKit Object
var WCCCStyleKit = {};
(function () {

    //// Drawing Methods

    function drawBurgerMenu(canvas, progress, targetFrame, resizing) {
        //// General Declarations
        canvas = initializeCanvas(typeof canvas === 'string' ? document.getElementById(canvas) : canvas);
        var context = canvas.getContext('2d');
        var pixelRatio = canvas.paintCodePixelRatio;

        //// Resize to Target Frame
        context.save();
        var resizedFrame = applyResizingBehavior(resizing, makeRect(0, 0, 205, 155), targetFrame);
        context.translate(resizedFrame.x, resizedFrame.y);
        context.scale(resizedFrame.w / 205, resizedFrame.h / 155);

        //// Color Declarations
        var menuColor = 'rgba(255, 255, 255, 1)';

        //// Variable Declarations
        var yProgress = progress < 50 ? progress * 2 : 100;
        var topYPos = yProgress < 100 ? yProgress / 2 : 50;
        var bottomYPos = yProgress < 100 ? 100 - yProgress / 2 : 50;
        var middleOpacity = yProgress < 100 ? 1 : 0;
        var rotationProgress = progress < 50 ? 0 : progress * 2 - 100;
        var topRotation = rotationProgress / 100 * 45;
        var bottomRotation = -(rotationProgress / 100) * 45;

        //// Rectangle 3 Drawing
        context.save();
        context.translate(102.5, topYPos + 27.5);
        context.rotate(-topRotation * Math.PI / 180);

        context.beginPath();
        context.rect(-87.5, -12.5, 175, 25);
        context.fillStyle = menuColor;
        context.fill();

        context.restore();

        //// Rectangle 2 Drawing
        context.save();
        context.translate(102.5, 77.5);

        context.save();
        context.globalAlpha = middleOpacity;
        context.beginPath();
        context.rect(-87.5, -12.5, 175, 25);
        context.fillStyle = menuColor;
        context.fill();
        context.restore();

        context.restore();

        //// Rectangle Drawing
        context.save();
        context.translate(102.5, bottomYPos + 27.5);
        context.rotate(-bottomRotation * Math.PI / 180);

        context.beginPath();
        context.rect(-87.5, -12.5, 175, 25);
        context.fillStyle = menuColor;
        context.fill();

        context.restore();

        context.restore();
    }

    //// Generated Images

    function imageOfBurgerMenu(pixelRatio, progress) {
        var canvas = document.createElement('canvas');
        canvas.width = 205;
        canvas.height = 155;
        canvas.style.width = canvas.width / pixelRatio + 'px';
        canvas.style.height = canvas.height / pixelRatio + 'px';
        canvas.paintCodePixelRatio = pixelRatio;
        var context = canvas.getContext('2d');
        context.scale(pixelRatio, pixelRatio);
        WCCCStyleKit.drawBurgerMenu(canvas, progress);
        return canvas;
    }

    //// Infrastructure

    function clearCanvas(canvas) {
        canvas = initializeCanvas(typeof canvas === 'string' ? document.getElementById(canvas) : canvas);
        canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
    }

    // Possible arguments for 'resizing' parameter are:
    //   'aspectfit': The content is proportionally resized to fit into the target rectangle.
    //   'aspectfill': The content is proportionally resized to completely fill the target rectangle.
    //   'stretch': The content is stretched to match the entire target rectangle.
    //   'center': The content is centered in the target rectangle, but it is NOT resized.
    function applyResizingBehavior(resizing, rect, targetRect) {
        if (targetRect === undefined || equalRects(rect, targetRect) || equalRects(targetRect, makeRect(0, 0, 0, 0))) {
            return rect;
        }

        var scales = makeSize(0, 0);
        scales.w = Math.abs(targetRect.w / rect.w);
        scales.h = Math.abs(targetRect.h / rect.h);

        switch (resizing) {
            case 'aspectfit':
                {
                    scales.w = Math.min(scales.w, scales.h);
                    scales.h = scales.w;
                    break;
                }
            case 'aspectfill':
                {
                    scales.w = Math.max(scales.w, scales.h);
                    scales.h = scales.w;
                    break;
                }
            case 'stretch':
            case undefined:
                break;
            case 'center':
                {
                    scales.w = 1;
                    scales.h = 1;
                    break;
                }
            default:
                throw 'Unknown resizing behavior "' + resizing + '". Use "aspectfit", "aspectfill", "stretch" or "center" as resizing behavior.';
        }

        var result = makeRect(Math.min(rect.x, rect.x + rect.w), Math.min(rect.y, rect.y + rect.h), Math.abs(rect.w), Math.abs(rect.h));
        result.w *= scales.w;
        result.h *= scales.h;
        result.x = targetRect.x + (targetRect.w - result.w) / 2;
        result.y = targetRect.y + (targetRect.h - result.h) / 2;
        return result;
    }

    function makeRect(x, y, w, h) {
        return { x: x, y: y, w: w, h: h };
    }

    function equalRects(r1, r2) {
        return r1.x === r2.x && r1.y === r2.y && r1.w == r2.w && r1.h === r2.h;
    }

    function makeSize(w, h) {
        return { w: w, h: h };
    }

    function initializeCanvas(canvas) {
        if ('paintCodePixelRatio' in canvas) return canvas;
        // This function should only be called once on each canvas.
        var context = canvas.getContext('2d');

        var devicePixelRatio = window.devicePixelRatio || 1;
        var backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

        var pixelRatio = devicePixelRatio / backingStorePixelRatio;

        canvas.style.width = canvas.width + 'px';
        canvas.style.height = canvas.height + 'px';
        canvas.width *= pixelRatio;
        canvas.height *= pixelRatio;
        canvas.paintCodePixelRatio = pixelRatio;

        context.scale(pixelRatio, pixelRatio);
        return canvas;
    }

    //// Public Interface

    // Drawing Methods
    WCCCStyleKit.drawBurgerMenu = drawBurgerMenu;

    // Generated Images
    WCCCStyleKit.imageOfBurgerMenu = imageOfBurgerMenu;

    // Utilities
    WCCCStyleKit.clearCanvas = clearCanvas;
    WCCCStyleKit.makeRect = makeRect;
})();